El shell Bash

MacProgramadores

$ declare -p C
declare -a C='([5]="Cosa" [6]="Casa" [7]="Perro")'
Una forma útil de rellenar un array es a partir de las líneas devueltas por una
sustitución de comandos usando la forma de inicialización B=(...), y dentro
de los paréntesis ponemos la sustitución de comandos. Por ejemplo, para
obtener un array con los nombres de ficheros de un directorio podemos usar:
$ B=($(ls -1))
$ declare -p B
declare -a B='([0]="Desktop" [1]="Documents"
[2]="Library" [3]="Movies" [4]="Music" [5]=Pictures"
Para acceder a los elementos usamos el operador corchete [] para indicar el
índice del elemento a acceder, y en este caso es obligatorio encerrar entre
llaves {} la variable:
$ echo ${B[2]}
Library
Si no indicamos índice de elemento, por defecto nos coge el elemento de
índice 0:
$ echo $B
Desktop
Y ésta es la razón por la que hay que encerrar los elementos entre llaves,
porque sino nos coge el primer elemento:
$ echo $B[3]
Movies[3]
También podemos inicializar un array introduciendo valores directamente con
el operador corchete:
$ D[2]=Casa
$ D[0]=Avion
$ declare -p D
declare -a D='([0]="Avion" [2]="Casa")'
Podemos usar los índices especiales * y @, los cuales retornan todos los
elementos del array de la misma forma que lo hacen los parámetros
posiciónales: Cuando no están encerrados entre comillas débiles ambos
devuelven una cadena con los elementos separados por espacio, pero cuando
se encierran entre comillas débiles @ devuelve una cadena con los elementos
separados por espacio, y * devuelve una cadena con los elementos separados
por el valor de IFS. En cualquiera de los casos, el array se pierde, y lo que
recibimos es una cadena de caracteres:
Pág 102

