El shell Bash

MacProgramadores

else
pos=' '
fi
echo "$i:$bp$pos${_lineas[$i]}"
done
) | more
}
Listado 9.6: Implementación de _ponbp()

Hay dos problemas que se pueden producir a la hora de que el usuario ponga
un breakpoint: El primero es que ponga el breakpoint más allá de la longitud
del script original, en este caso simplemente el breakpoint nunca se
alcanzará. El segundo es que ponga un breakpoint en una línea en banco, la
cual no produce la señal SIGDEBUG, y al usar el comando g el programa no
se detendrá. Para detectar este segundo caso hemos puesto la condición [ n "${_lineas[$1]}" ].
Después de realizar estos test podemos añadir el breakpoint al array
_lineasbp, el cual tiene los números de líneas donde hay breakpoints. Para
hacer esto necesitamos un código un poco más extraño de lo normal, tal
como puede apreciar. La idea es generar un array con los elementos del array
más el nuevo elemento ${_lineasbp[*]} $1, después, este texto se pasa
por el comando sort -n para ordenar los números y por último generamos
un array encerrando la sustitución de comandos entre paréntesis, tal como se
explicó en el apartado 3.4 del Tema 6.
# Borra el breakpoint indicado, o todos si no
# se da argumento
function _borrabp
{
if [ -z "$1" ]; then
unset _lineasbp[*]
_msg "Todos los breakpoints fueron eliminados"
elif [ $(echo $1|grep '^[0-9]*') ]; then
local i
_lineasbp=( $(echo $(for i in ${_lineasbp[*]}
do
if (($1!=$i)); then
echo $i
fi
done) ) )
_msg "Breakpoint en linea $1 eliminado"
else
_msg "Especifique un numero de linea valido"
fi
}
Listado 9.7: Implementación de _borrabp()

Pág 164

